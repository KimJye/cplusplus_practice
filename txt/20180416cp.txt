20180416 <c++>

* 매크로 함수는 전처리기에의해서 실행됨, 
* 인라인 함수는 컴파일러에의해서 실행됨, 일반함수앞에 inline만 붙이면 됨. 구현의 용이성, 
 	 매크로 함수의 장점을 그대로 반영, 컴파일러에게 최적화의 기회 제공(알아서 컴파일이 쓸건 쓰고 무시할건 무시하니까 애매하면 inline써라)
 
* const 키워드
 - const int n=10; // n=12;안됨
 - const int * n;// 데이터 상수화임. n이라는 포인터를 통해서 n이 가리키는 데이터 변경 못함
 - int *const n; //포인터 상수화임. n=&a(x)
 - const int* const n;//n의 데이터와 포인터 상수화

* stack - 컴파일 타입 크기 결정, 지역변수, 매개변수
* heap - 런 타임 크기 결정, 프로그래머 할당
* data - 데이터 영역, 전역변수, static변수

* 포인터와 참조자를 구분하자.
- 포인터: ->사용
- 참조자: . 사용
둘다 다른 객체를 간접적으로 참조한다.
참조자는 null reference가 없다. 참조자가 참조하는 대상은 어떤 경우든지 메모리 공간을 차지한 객체를 참조하고 있어야 한다.
포인터는 null로 세팅이 가능하다.
즉 포인터는 null 테스트를 하는 것이 보통이다.
포인터는 다른 객체의 주소값으로 얼마든지 바꾸어 세팅이 가능하다.
하지만 참조자는 초기화 될 때 참조했던 그 객체만 참조한다.

string s1("A");
string s2("B");

string & rs=s1;//rs는 s1을 참조한다.
string * ps=&s1;//ps는 s1을 가리킨다.

rs=s2;//rs는 여전히 s1을 가리키지만 s1의 값은 s2의 값으로 변경된다.
ps=&s2;//ps는 이제 s2를 가리킨다. s1과는 아무런 관계가 없어졌다.